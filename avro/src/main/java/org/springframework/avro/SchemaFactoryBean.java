package org.springframework.avro;

import org.apache.avro.Schema;
import org.apache.avro.reflect.ReflectData;
import org.apache.avro.specific.SpecificData;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.core.io.Resource;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

/**
 * <P>Provides a consistent way to return a {@link org.apache.avro.Schema} object which is crucial for every use of Avro in serialization
 * <p>This factory can build up a {@link Schema schema} by looking at a generated Avro class (for example, you might use the Maven Mojo to
 * generate classes based on a schema or defintion at compile time).
 * <p>Alternatively, you can specify a standard {@link Resource Spring resource} and this factory will build the schema from the resource specified.
 * <p>Finally, you might specify an inline schema defintion as well (particularly attractive using Spring's XML-based configuration).
 *
 * @author Josh Long
 */
public class SchemaFactoryBean implements FactoryBean<Schema>, InitializingBean {
	private String schema;
	private Schema result;
	private Log log = LogFactory.getLog(getClass());
	private Resource location;
	private volatile boolean setup = false;

	private Class targetClass;

	private final Object lock = new Object();

	/**
	 * <p/>
	 * first attempts to consult the registry of known types ({@link SpecificData}). This registry specifically
	 * speaks to the types that are generated by the Avro compiler
	 * or those that are primitives or well known cases, like {@link String strings}.
	 * <p/>
	 * <P> Failing that, this will attempt to generate a {@link Schema} using reflection.
	 * <p/>
	 * <P> Failing that, this will return <CODE>null</CODE>.
	 * </p>
	 *
	 * @param clazz the class you'd like to find a Schema for
	 * @return the schema
	 */
	protected Schema findSchemaFor(Class<?> clazz) {
		// lets see if we can do this lazily
		//

		Schema result = null;
		try {
			SpecificData specificData = SpecificData.get();
			result = specificData.getSchema(clazz);
		} catch (Throwable th) {
			if (log.isDebugEnabled()) {
				log.debug("Error: could not get the Schema by consulting 'SpecificData'", th);
			}
		}

		if (null != result) {
			return result;
		}

		try {
			ReflectData reflectData = ReflectData.get();
			result = reflectData.getSchema(clazz);
		} catch (Throwable th) {
			if (log.isDebugEnabled()) {
				log.debug("Error: could not get the Schema by consulting 'ReflectData'", th);
			}
		}
		return result;

	}

	/**
	 * @param c
	 */
	public SchemaFactoryBean(Class c) {
		this.result = findSchemaFor(c);
	}

	/**
	 * builds the {@link #result} based on a JSON string. Particularly useful for in-situ
	 * definitions (perhaps using the XML configuration approach?)
	 */
	public SchemaFactoryBean(String schema) {
		this.schema = schema;
		Assert.notNull(this.schema, "the 'schema' must not be null");
		try {
			afterPropertiesSet();
		} catch (Exception e) {
			if (log.isErrorEnabled()) {
				log.error("something went wrong in trying to construct the Schema ");
			}
		}

	}


	/**
	 * builds the {@link #result} based on a Spring resource, which it then uses to load the {@link Schema} through an {@link java.io.InputStream}.
	 *
	 * @param location the location (e.g., <CODE>'classpath:/foo/bar.avsc'</CODE>)
	 */
	public SchemaFactoryBean(Resource location) {
		this.location = location;
		Assert.notNull(this.location, "the 'location' must not be null");
		try {
			afterPropertiesSet();
		} catch (Exception e) {
			if (log.isErrorEnabled()) {
				log.error("something went wrong in trying to construct the Schema ");
			}
		}
	}

	/**
	 * <P> points to a location on (URL, file, etc.) for the file to be read in
	 * <P> this option is mutually exclusive with the {@link #schema schema property}.
	 *
	 * @param location the location of a <CODE>.avpr</CODE> (or otherwise) file to read in
	 */
	public void setLocation(Resource location) {
		this.location = location;
	}

	/**
	 * <p> The schema itself might be defined inline, in the XML or Java configuration.
	 * <p>this option is mutually exclusive with the {@link #location location property}
	 *
	 * @param schema the string for the schema itself.
	 */
	public void setSchema(String schema) {
		this.schema = schema;
	}

	@Override
	public Schema getObject() throws Exception {
		afterPropertiesSet();
		return this.result;
	}

	@Override
	public Class<?> getObjectType() {
		return Schema.class;
	}

	@Override
	public boolean isSingleton() {
		return true;
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		synchronized (this.lock) {
			if (this.setup || this.result != null) {
				return;
			}

			boolean inline = StringUtils.hasText(this.schema);
			boolean external = location != null;
			boolean somethingsProvided = inline || external;

			Assert.isTrue(somethingsProvided, "the 'location' property or the 'schema' property must be set (but not both)");

			if (!StringUtils.hasText(schema)) {
				if (log.isDebugEnabled()) {
					log.debug("the 'validate' property is ignored if you do not provide a schema JSON string defintion inline");
				}
			}

			if (inline) {
				result = Schema.parse(this.schema, true);
			} else {
				result = Schema.parse(this.location.getInputStream());
			}
			this.setup = true;
		}
	}

	public void setTargetClass(Class targetClass) {
		this.targetClass = targetClass;
	}
}
